{
    "docs": [
        {
            "location": "/", 
            "text": "zend-uri\n\n\n\n\n\n\nzend-uri aids in manipulating and validating Uniform Resource Identifiers\n(\nURIs\n). zend-uri exists primarily to\nassist other components, such as zend-http, but is also useful as a standalone\nutility.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-uri/issues\n\n\nDocumentation is at https://zendframework.github.io/zend-uri/", 
            "title": "Home"
        }, 
        {
            "location": "/#zend-uri", 
            "text": "zend-uri aids in manipulating and validating Uniform Resource Identifiers\n( URIs ). zend-uri exists primarily to\nassist other components, such as zend-http, but is also useful as a standalone\nutility.   File issues at https://github.com/zendframework/zend-uri/issues  Documentation is at https://zendframework.github.io/zend-uri/", 
            "title": "zend-uri"
        }, 
        {
            "location": "/intro/", 
            "text": "Introduction\n\n\nzend-uri aids in manipulating and validating \nUniform \nResource Identifiers\n\n(\nURIs\n). zend-uri exists primarily\nto assist other components, such as\n\nzend-http\n, but is also useful as a\nstandalone utility.\n\n\nURIs always begin with a scheme, followed by a colon. The construction of the\nmany different schemes varies significantly. The zend-uri component provides the\n\nZend\\Uri\\UriFactory\n that returns an instance of the appropriate class\nimplementing \nZend\\Uri\\UriInterface\n for the given scheme (assuming the factory\ncan locate one).", 
            "title": "Intro"
        }, 
        {
            "location": "/intro/#introduction", 
            "text": "zend-uri aids in manipulating and validating  Uniform \nResource Identifiers \n( URIs ). zend-uri exists primarily\nto assist other components, such as zend-http , but is also useful as a\nstandalone utility.  URIs always begin with a scheme, followed by a colon. The construction of the\nmany different schemes varies significantly. The zend-uri component provides the Zend\\Uri\\UriFactory  that returns an instance of the appropriate class\nimplementing  Zend\\Uri\\UriInterface  for the given scheme (assuming the factory\ncan locate one).", 
            "title": "Introduction"
        }, 
        {
            "location": "/usage/", 
            "text": "Usage\n\n\nCreating a New URI\n\n\nZend\\Uri\\UriFactory\n will build a new URI from scratch if only a scheme is\npassed to \nZend\\Uri\\UriFactory::factory()\n.\n\n\nCreating a New URI with ZendUriUriFactory::factory()\n\n\n// To create a new URI from scratch, pass only the scheme\n// followed by a colon.\n$uri = Zend\\Uri\\UriFactory::factory('http:');\n\n// $uri instanceof Zend\\Uri\\UriInterface\n\n\n\n\nTo create a new URI from scratch, pass only the scheme followed by a colon to\n\nZend\\Uri\\UriFactory::factory()\n. If an unsupported scheme is passed and no\nscheme-specific class is specified, a\n\nZend\\Uri\\Exception\\InvalidArgumentException\n will be thrown.\n\n\nIf the scheme or URI passed is supported, \nZend\\Uri\\UriFactory::factory()\n will\nreturn a class implementing \nZend\\Uri\\UriInterface\n that specializes in the\nscheme referenced.\n\n\n\n\nSupported schemes\n\n\nAt the time of writing, zend-uri provides built-in support for the following\nschemes only: HTTP, HTTPS, MAILTO and FILE.\n\n\n\n\nCreating a New Custom-Class URI\n\n\nYou can specify a custom class to be used when using the \nZend\\Uri\\UriFactory\n\nby registering your class with the \nUriFactory\n using\n\nZend\\Uri\\UriFactory::registerScheme($scheme, $class)\n.  This enables you to\ncreate your own URI class and instantiate new URI objects based on your own\ncustom classes.\n\n\nThe 2nd parameter passed to \nZend\\Uri\\UriFactory::registerScheme()\n must be a\nstring with the name of a class implementing \nZend\\Uri\\UriInterface\n. The class\nmust either be already loaded, or be loadable by the autoloader.\n\n\nCreating a URI using a custom class\n\n\nThe following registers the \nftp\n scheme with a custom URI class:\n\n\nuse MyNamespace\\MyClass;\nuse Zend\\Uri\\UriFactory\n\nUriFactory::registerScheme('ftp', MyClass::class);\n\n$ftpUri = UriFactory::factory(\n    'ftp://user@ftp.example.com/path/file'\n);\n\n// $ftpUri is an instance of MyLibrary\\MyClass, which implements\n// Zend\\Uri\\UriInterface\n\n\n\n\nManipulating an Existing URI\n\n\nTo manipulate an existing URI, pass the entire URI as a string to\n\nZend\\Uri\\UriFactory::factory()\n, and then manipulate the instance returned.\n\n\nManipulating an Existing URI with Zend\\Uri\\UriFactory::factory()\n\n\nuse Zend\\Uri\\UriFactory;\n\n// To manipulate an existing URI, pass it in.\n$uri = UriFactory::factory('http://www.zend.com');\n\n// $uri instanceof Zend\\Uri\\UriInterface\n\n\n\n\nThe URI will be parsed and validated. If it is found to be invalid, a\n\nZend\\Uri\\Exception\\InvalidArgumentException\n will be thrown immediately.\nOtherwise, \nZend\\Uri\\UriFactory::factory()\n will return a class implementing\n\nZend\\Uri\\UriInterface\n that specializes in the scheme to be manipulated.\n\n\nCommon Instance Methods\n\n\nThe \nZend\\Uri\\UriInterface\n defines several instance methods that are useful for\nworking with any kind of URI.\n\n\nGetting the Scheme of the URI\n\n\nThe scheme of the URI is the part of the URI that precedes the colon. For\nexample, the scheme of \nhttp://johndoe@example.com/my/path?query#token\n is\n'http'.\n\n\n$uri = Zend\\Uri\\UriFactory::factory('mailto:john.doe@example.com');\n\n$scheme = $uri-\ngetScheme();  // \nmailto\n\n\n\n\nThe \ngetScheme()\n instance method returns only the scheme part of the URI\nobject (not the separator).\n\n\nGetting the Userinfo of the URI\n\n\nThe userinfo of the URI is the optional part of the URI that follows the\ncolon and comes before the host-part. For example, the userinfo of\n\nhttp://johndoe@example.com/my/path?query#token\n is 'johndoe'.\n\n\n$uri = Zend\\Uri\\UriFactory::factory('mailto:john.doe@example.com');\n\n$scheme = $uri-\ngetUserinfo();  // \njohn.doe\n\n\n\n\nThe \ngetUserinfo()\n method returns only the userinfo part of the URI object.\n\n\nGetting the host of the URI\n\n\nThe host of the URI is the optional part of the URI that follows the\nuser-part and comes before the path-part. For example, the host of\n\nhttp://johndoe@example.com/my/path?query#token\n is 'example.com'.\n\n\n$uri = Zend\\Uri\\UriFactory::factory('mailto:john.doe@example.com');\n\n$scheme = $uri-\ngetHost();  // \nexample.com\n\n\n\n\nThe \ngetHost()\n method returns only the host part of the URI object.\n\n\nGetting the port of the URI\n\n\nThe port of the URI is the optional part of the URI that follows the host-part\nand comes before the path-part. For example, the host of\n\nhttp://johndoe@example.com:80/my/path?query#token\n is '80'.\n\n\n$uri = Zend\\Uri\\UriFactory::factory('http://example.com:8080');\n\n$scheme = $uri-\ngetPort();  // \n8080\n\n\n\n\nConcrete URI instances can define default ports that can be returned when no\nport is given in the URI:\n\n\n$uri = Zend\\Uri\\UriFactory::factory('http://example.com');\n\n$scheme = $uri-\ngetPort();  // \n80\n\n\n\n\nThe \ngetHost()\n method returns only the port part of the URI object.\n\n\nGetting the path of the URI\n\n\nThe path of the URI is a mandatory part of the URI that follows the port\nand comes before the query-part. For example, the path of\n\nhttp://johndoe@example.com:80/my/path?query#token\n is '/my/path'.\n\n\n$uri = Zend\\Uri\\UriFactory::factory('http://example.com:80/my/path?a=b\nc=d#token');\n\n$scheme = $uri-\ngetPath();  // \n/my/path\n\n\n\n\nThe \ngetPath()\n method returns only the path of the URI object.\n\n\nGetting the query-part of the URI\n\n\nThe query-part of the URI is an optional part of the URI that follows the\npath and comes before the fragment. For example, the query of\n\nhttp://johndoe@example.com:80/my/path?query#token\n is 'query'.\n\n\n$uri = Zend\\Uri\\UriFactory::factory('http://example.com:80/my/path?a=b\nc=d#token');\n\n$scheme = $uri-\ngetQuery();  // \na=b\nc=d\n\n\n\n\nThe \ngetQuery()\n method returns only the query-part of the URI object.\n\n\nThe query string often contains key=value pairs and therefore can be split into an\nassociative array. This array can be retrieved using \ngetQueryAsArray()\n:\n\n\n$uri = Zend\\Uri\\UriFactory::factory('http://example.com:80/my/path?a=b\nc=d#token');\n\n$scheme = $uri-\ngetQueryAsArray();\n// [\n//  'a' =\n 'b',\n//  'c' =\n 'd',\n// ]\n\n\n\n\nGetting the fragment-part of the URI\n\n\nThe fragment-part of the URI is an optional part of the URI that follows\nthe query. For example, the fragment of\n\nhttp://johndoe@example.com:80/my/path?query#token\n is 'token'.\n\n\n$uri = Zend\\Uri\\UriFactory::factory('http://example.com:80/my/path?a=b\nc=d#token');\n\n$scheme = $uri-\ngetFragment();  // \ntoken\n\n\n\n\nThe \ngetFragment()\n method returns only the fragment-part of the URI object.\n\n\nGetting the Entire URI\n\n\nThe \ntoString()\n method returns the string representation of the entire \nURI\n.\n\n\n$uri = Zend\\Uri\\UriFactory::factory('http://www.zend.com');\n\necho $uri-\ntoString();  // \nhttp://www.zend.com\n\n\n// Alternate method:\necho (string) $uri;     // \nhttp://www.zend.com\n\n\n\n\nThe \nZend\\Uri\\UriInterface\n defines also the magic \n__toString()\n method that\nreturns the string representation of the URI when the object is cast to a\nstring.\n\n\nValidating the URI\n\n\nWhen using \nZend\\Uri\\UriFactory::factory()\n, the given URI will always be\nvalidated and a \nZend\\Uri\\Exception\\InvalidArgumentException\n will be thrown\nwhen the URI is invalid. However, after the \nZend\\Uri\\UriInterface\n is\ninstantiated for a new URI or an existing valid one, it is possible that the URI\ncan later become invalid after it is manipulated.\n\n\n$uri = Zend\\Uri\\UriFactory::factory('http://www.zend.com');\n\n$isValid = $uri-\nisValid();  // TRUE\n\n\n\n\nThe \nisValid()\n instance method provides a means to check that the URI object\nis still valid.", 
            "title": "Usage"
        }, 
        {
            "location": "/usage/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/usage/#creating-a-new-uri", 
            "text": "Zend\\Uri\\UriFactory  will build a new URI from scratch if only a scheme is\npassed to  Zend\\Uri\\UriFactory::factory() .", 
            "title": "Creating a New URI"
        }, 
        {
            "location": "/usage/#creating-a-new-uri-with-zenduriurifactoryfactory", 
            "text": "// To create a new URI from scratch, pass only the scheme\n// followed by a colon.\n$uri = Zend\\Uri\\UriFactory::factory('http:');\n\n// $uri instanceof Zend\\Uri\\UriInterface  To create a new URI from scratch, pass only the scheme followed by a colon to Zend\\Uri\\UriFactory::factory() . If an unsupported scheme is passed and no\nscheme-specific class is specified, a Zend\\Uri\\Exception\\InvalidArgumentException  will be thrown.  If the scheme or URI passed is supported,  Zend\\Uri\\UriFactory::factory()  will\nreturn a class implementing  Zend\\Uri\\UriInterface  that specializes in the\nscheme referenced.", 
            "title": "Creating a New URI with ZendUriUriFactory::factory()"
        }, 
        {
            "location": "/usage/#supported-schemes", 
            "text": "At the time of writing, zend-uri provides built-in support for the following\nschemes only: HTTP, HTTPS, MAILTO and FILE.", 
            "title": "Supported schemes"
        }, 
        {
            "location": "/usage/#creating-a-new-custom-class-uri", 
            "text": "You can specify a custom class to be used when using the  Zend\\Uri\\UriFactory \nby registering your class with the  UriFactory  using Zend\\Uri\\UriFactory::registerScheme($scheme, $class) .  This enables you to\ncreate your own URI class and instantiate new URI objects based on your own\ncustom classes.  The 2nd parameter passed to  Zend\\Uri\\UriFactory::registerScheme()  must be a\nstring with the name of a class implementing  Zend\\Uri\\UriInterface . The class\nmust either be already loaded, or be loadable by the autoloader.", 
            "title": "Creating a New Custom-Class URI"
        }, 
        {
            "location": "/usage/#creating-a-uri-using-a-custom-class", 
            "text": "The following registers the  ftp  scheme with a custom URI class:  use MyNamespace\\MyClass;\nuse Zend\\Uri\\UriFactory\n\nUriFactory::registerScheme('ftp', MyClass::class);\n\n$ftpUri = UriFactory::factory(\n    'ftp://user@ftp.example.com/path/file'\n);\n\n// $ftpUri is an instance of MyLibrary\\MyClass, which implements\n// Zend\\Uri\\UriInterface", 
            "title": "Creating a URI using a custom class"
        }, 
        {
            "location": "/usage/#manipulating-an-existing-uri", 
            "text": "To manipulate an existing URI, pass the entire URI as a string to Zend\\Uri\\UriFactory::factory() , and then manipulate the instance returned.", 
            "title": "Manipulating an Existing URI"
        }, 
        {
            "location": "/usage/#manipulating-an-existing-uri-with-zend92uri92urifactoryfactory", 
            "text": "use Zend\\Uri\\UriFactory;\n\n// To manipulate an existing URI, pass it in.\n$uri = UriFactory::factory('http://www.zend.com');\n\n// $uri instanceof Zend\\Uri\\UriInterface  The URI will be parsed and validated. If it is found to be invalid, a Zend\\Uri\\Exception\\InvalidArgumentException  will be thrown immediately.\nOtherwise,  Zend\\Uri\\UriFactory::factory()  will return a class implementing Zend\\Uri\\UriInterface  that specializes in the scheme to be manipulated.", 
            "title": "Manipulating an Existing URI with Zend\\Uri\\UriFactory::factory()"
        }, 
        {
            "location": "/usage/#common-instance-methods", 
            "text": "The  Zend\\Uri\\UriInterface  defines several instance methods that are useful for\nworking with any kind of URI.", 
            "title": "Common Instance Methods"
        }, 
        {
            "location": "/usage/#getting-the-scheme-of-the-uri", 
            "text": "The scheme of the URI is the part of the URI that precedes the colon. For\nexample, the scheme of  http://johndoe@example.com/my/path?query#token  is\n'http'.  $uri = Zend\\Uri\\UriFactory::factory('mailto:john.doe@example.com');\n\n$scheme = $uri- getScheme();  //  mailto  The  getScheme()  instance method returns only the scheme part of the URI\nobject (not the separator).", 
            "title": "Getting the Scheme of the URI"
        }, 
        {
            "location": "/usage/#getting-the-userinfo-of-the-uri", 
            "text": "The userinfo of the URI is the optional part of the URI that follows the\ncolon and comes before the host-part. For example, the userinfo of http://johndoe@example.com/my/path?query#token  is 'johndoe'.  $uri = Zend\\Uri\\UriFactory::factory('mailto:john.doe@example.com');\n\n$scheme = $uri- getUserinfo();  //  john.doe  The  getUserinfo()  method returns only the userinfo part of the URI object.", 
            "title": "Getting the Userinfo of the URI"
        }, 
        {
            "location": "/usage/#getting-the-host-of-the-uri", 
            "text": "The host of the URI is the optional part of the URI that follows the\nuser-part and comes before the path-part. For example, the host of http://johndoe@example.com/my/path?query#token  is 'example.com'.  $uri = Zend\\Uri\\UriFactory::factory('mailto:john.doe@example.com');\n\n$scheme = $uri- getHost();  //  example.com  The  getHost()  method returns only the host part of the URI object.", 
            "title": "Getting the host of the URI"
        }, 
        {
            "location": "/usage/#getting-the-port-of-the-uri", 
            "text": "The port of the URI is the optional part of the URI that follows the host-part\nand comes before the path-part. For example, the host of http://johndoe@example.com:80/my/path?query#token  is '80'.  $uri = Zend\\Uri\\UriFactory::factory('http://example.com:8080');\n\n$scheme = $uri- getPort();  //  8080  Concrete URI instances can define default ports that can be returned when no\nport is given in the URI:  $uri = Zend\\Uri\\UriFactory::factory('http://example.com');\n\n$scheme = $uri- getPort();  //  80  The  getHost()  method returns only the port part of the URI object.", 
            "title": "Getting the port of the URI"
        }, 
        {
            "location": "/usage/#getting-the-path-of-the-uri", 
            "text": "The path of the URI is a mandatory part of the URI that follows the port\nand comes before the query-part. For example, the path of http://johndoe@example.com:80/my/path?query#token  is '/my/path'.  $uri = Zend\\Uri\\UriFactory::factory('http://example.com:80/my/path?a=b c=d#token');\n\n$scheme = $uri- getPath();  //  /my/path  The  getPath()  method returns only the path of the URI object.", 
            "title": "Getting the path of the URI"
        }, 
        {
            "location": "/usage/#getting-the-query-part-of-the-uri", 
            "text": "The query-part of the URI is an optional part of the URI that follows the\npath and comes before the fragment. For example, the query of http://johndoe@example.com:80/my/path?query#token  is 'query'.  $uri = Zend\\Uri\\UriFactory::factory('http://example.com:80/my/path?a=b c=d#token');\n\n$scheme = $uri- getQuery();  //  a=b c=d  The  getQuery()  method returns only the query-part of the URI object.  The query string often contains key=value pairs and therefore can be split into an\nassociative array. This array can be retrieved using  getQueryAsArray() :  $uri = Zend\\Uri\\UriFactory::factory('http://example.com:80/my/path?a=b c=d#token');\n\n$scheme = $uri- getQueryAsArray();\n// [\n//  'a' =  'b',\n//  'c' =  'd',\n// ]", 
            "title": "Getting the query-part of the URI"
        }, 
        {
            "location": "/usage/#getting-the-fragment-part-of-the-uri", 
            "text": "The fragment-part of the URI is an optional part of the URI that follows\nthe query. For example, the fragment of http://johndoe@example.com:80/my/path?query#token  is 'token'.  $uri = Zend\\Uri\\UriFactory::factory('http://example.com:80/my/path?a=b c=d#token');\n\n$scheme = $uri- getFragment();  //  token  The  getFragment()  method returns only the fragment-part of the URI object.", 
            "title": "Getting the fragment-part of the URI"
        }, 
        {
            "location": "/usage/#getting-the-entire-uri", 
            "text": "The  toString()  method returns the string representation of the entire  URI .  $uri = Zend\\Uri\\UriFactory::factory('http://www.zend.com');\n\necho $uri- toString();  //  http://www.zend.com \n\n// Alternate method:\necho (string) $uri;     //  http://www.zend.com  The  Zend\\Uri\\UriInterface  defines also the magic  __toString()  method that\nreturns the string representation of the URI when the object is cast to a\nstring.", 
            "title": "Getting the Entire URI"
        }, 
        {
            "location": "/usage/#validating-the-uri", 
            "text": "When using  Zend\\Uri\\UriFactory::factory() , the given URI will always be\nvalidated and a  Zend\\Uri\\Exception\\InvalidArgumentException  will be thrown\nwhen the URI is invalid. However, after the  Zend\\Uri\\UriInterface  is\ninstantiated for a new URI or an existing valid one, it is possible that the URI\ncan later become invalid after it is manipulated.  $uri = Zend\\Uri\\UriFactory::factory('http://www.zend.com');\n\n$isValid = $uri- isValid();  // TRUE  The  isValid()  instance method provides a means to check that the URI object\nis still valid.", 
            "title": "Validating the URI"
        }
    ]
}